// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: protos/devloop/v1/devloop_gateway.proto

package v1mcp

import (
	v1 "github.com/panyam/devloop/gen/go/protos/devloop/v1"
)

import (
	"connectrpc.com/connect"
	"context"
	"encoding/json"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	grpc "google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"
)

var (
	GatewayClientService_GetConfigTool         = mcp.Tool{Name: "devloop_gateway_v1_GatewayClientService_GetConfig", Description: "Get the configuration for a specific devloop project.\n", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
	GatewayClientService_GetRuleStatusTool     = mcp.Tool{Name: "devloop_gateway_v1_GatewayClientService_GetRuleStatus", Description: "Get the detailed status of a specific rule within a project.\n", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x72, 0x75, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
	GatewayClientService_ListProjectsTool      = mcp.Tool{Name: "devloop_gateway_v1_GatewayClientService_ListProjects", Description: "List all registered devloop projects.\n", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
	GatewayClientService_ListWatchedPathsTool  = mcp.Tool{Name: "devloop_gateway_v1_GatewayClientService_ListWatchedPaths", Description: "List all glob patterns being watched by a specific devloop project.\n", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
	GatewayClientService_ReadFileContentTool   = mcp.Tool{Name: "devloop_gateway_v1_GatewayClientService_ReadFileContent", Description: "Read and return the content of a specific file within a devloop project.\n", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x61, 0x74, 0x68, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
	GatewayClientService_TriggerRuleClientTool = mcp.Tool{Name: "devloop_gateway_v1_GatewayClientService_TriggerRuleClient", Description: "Manually trigger a specific rule in a devloop project.\n", InputSchema: mcp.ToolInputSchema{Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x2c, 0x22, 0x72, 0x75, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}}
)

// DevloopGatewayServiceServer is compatible with the grpc-go server interface.
type DevloopGatewayServiceServer interface {
}

// GatewayClientServiceServer is compatible with the grpc-go server interface.
type GatewayClientServiceServer interface {
	GetConfig(ctx context.Context, req *v1.GetConfigRequest) (*v1.GetConfigResponse, error)
	GetRuleStatus(ctx context.Context, req *v1.GetRuleStatusRequest) (*v1.GetRuleStatusResponse, error)
	ListProjects(ctx context.Context, req *v1.ListProjectsRequest) (*v1.ListProjectsResponse, error)
	ListWatchedPaths(ctx context.Context, req *v1.ListWatchedPathsRequest) (*v1.ListWatchedPathsResponse, error)
	ReadFileContent(ctx context.Context, req *v1.ReadFileContentRequest) (*v1.ReadFileContentResponse, error)
	TriggerRuleClient(ctx context.Context, req *v1.TriggerRuleClientRequest) (*v1.TriggerRuleClientResponse, error)
}

func RegisterDevloopGatewayServiceHandler(s *mcpserver.MCPServer, srv DevloopGatewayServiceServer) {
}
func RegisterGatewayClientServiceHandler(s *mcpserver.MCPServer, srv GatewayClientServiceServer) {
	s.AddTool(GatewayClientService_GetConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetConfigRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.GetConfig(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_GetRuleStatusTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetRuleStatusRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.GetRuleStatus(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ListProjectsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListProjectsRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ListProjects(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ListWatchedPathsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListWatchedPathsRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ListWatchedPaths(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ReadFileContentTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ReadFileContentRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.ReadFileContent(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_TriggerRuleClientTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.TriggerRuleClientRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.TriggerRuleClient(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// DevloopGatewayServiceClient is compatible with the grpc-go client interface.
type DevloopGatewayServiceClient interface {
}

// GatewayClientServiceClient is compatible with the grpc-go client interface.
type GatewayClientServiceClient interface {
	GetConfig(ctx context.Context, req *v1.GetConfigRequest, opts ...grpc.CallOption) (*v1.GetConfigResponse, error)
	GetRuleStatus(ctx context.Context, req *v1.GetRuleStatusRequest, opts ...grpc.CallOption) (*v1.GetRuleStatusResponse, error)
	ListProjects(ctx context.Context, req *v1.ListProjectsRequest, opts ...grpc.CallOption) (*v1.ListProjectsResponse, error)
	ListWatchedPaths(ctx context.Context, req *v1.ListWatchedPathsRequest, opts ...grpc.CallOption) (*v1.ListWatchedPathsResponse, error)
	ReadFileContent(ctx context.Context, req *v1.ReadFileContentRequest, opts ...grpc.CallOption) (*v1.ReadFileContentResponse, error)
	TriggerRuleClient(ctx context.Context, req *v1.TriggerRuleClientRequest, opts ...grpc.CallOption) (*v1.TriggerRuleClientResponse, error)
}

// ConnectDevloopGatewayServiceClient is compatible with the connectrpc-go client interface.
type ConnectDevloopGatewayServiceClient interface {
}

// ConnectGatewayClientServiceClient is compatible with the connectrpc-go client interface.
type ConnectGatewayClientServiceClient interface {
	GetConfig(ctx context.Context, req *connect.Request[v1.GetConfigRequest]) (*connect.Response[v1.GetConfigResponse], error)
	GetRuleStatus(ctx context.Context, req *connect.Request[v1.GetRuleStatusRequest]) (*connect.Response[v1.GetRuleStatusResponse], error)
	ListProjects(ctx context.Context, req *connect.Request[v1.ListProjectsRequest]) (*connect.Response[v1.ListProjectsResponse], error)
	ListWatchedPaths(ctx context.Context, req *connect.Request[v1.ListWatchedPathsRequest]) (*connect.Response[v1.ListWatchedPathsResponse], error)
	ReadFileContent(ctx context.Context, req *connect.Request[v1.ReadFileContentRequest]) (*connect.Response[v1.ReadFileContentResponse], error)
	TriggerRuleClient(ctx context.Context, req *connect.Request[v1.TriggerRuleClientRequest]) (*connect.Response[v1.TriggerRuleClientResponse], error)
}

// ForwardToConnectDevloopGatewayServiceClient registers a connectrpc client, to forward MCP calls to it.
func ForwardToConnectDevloopGatewayServiceClient(s *mcpserver.MCPServer, client ConnectDevloopGatewayServiceClient) {
}

// ForwardToConnectGatewayClientServiceClient registers a connectrpc client, to forward MCP calls to it.
func ForwardToConnectGatewayClientServiceClient(s *mcpserver.MCPServer, client ConnectGatewayClientServiceClient) {
	s.AddTool(GatewayClientService_GetConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetConfigRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetConfig(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_GetRuleStatusTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetRuleStatusRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetRuleStatus(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ListProjectsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListProjectsRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListProjects(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ListWatchedPathsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListWatchedPathsRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListWatchedPaths(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ReadFileContentTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ReadFileContentRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ReadFileContent(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_TriggerRuleClientTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.TriggerRuleClientRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.TriggerRuleClient(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// ForwardToDevloopGatewayServiceClient registers a gRPC client, to forward MCP calls to it.
func ForwardToDevloopGatewayServiceClient(s *mcpserver.MCPServer, client DevloopGatewayServiceClient) {
}

// ForwardToGatewayClientServiceClient registers a gRPC client, to forward MCP calls to it.
func ForwardToGatewayClientServiceClient(s *mcpserver.MCPServer, client GatewayClientServiceClient) {
	s.AddTool(GatewayClientService_GetConfigTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetConfigRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetConfig(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_GetRuleStatusTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.GetRuleStatusRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.GetRuleStatus(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ListProjectsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListProjectsRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListProjects(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ListWatchedPathsTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ListWatchedPathsRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ListWatchedPaths(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_ReadFileContentTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.ReadFileContentRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.ReadFileContent(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	s.AddTool(GatewayClientService_TriggerRuleClientTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req v1.TriggerRuleClientRequest

		message := request.Params.Arguments

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.TriggerRuleClient(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
