// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: devloop/v1/agents.proto

package v1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/panyam/devloop/gen/go/devloop/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// AgentServiceName is the fully-qualified name of the AgentService service.
	AgentServiceName = "devloop.v1.AgentService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// AgentServiceGetConfigProcedure is the fully-qualified name of the AgentService's GetConfig RPC.
	AgentServiceGetConfigProcedure = "/devloop.v1.AgentService/GetConfig"
	// AgentServiceGetRuleProcedure is the fully-qualified name of the AgentService's GetRule RPC.
	AgentServiceGetRuleProcedure = "/devloop.v1.AgentService/GetRule"
	// AgentServiceTriggerRuleProcedure is the fully-qualified name of the AgentService's TriggerRule
	// RPC.
	AgentServiceTriggerRuleProcedure = "/devloop.v1.AgentService/TriggerRule"
	// AgentServiceListWatchedPathsProcedure is the fully-qualified name of the AgentService's
	// ListWatchedPaths RPC.
	AgentServiceListWatchedPathsProcedure = "/devloop.v1.AgentService/ListWatchedPaths"
	// AgentServiceStreamLogsProcedure is the fully-qualified name of the AgentService's StreamLogs RPC.
	AgentServiceStreamLogsProcedure = "/devloop.v1.AgentService/StreamLogs"
)

// AgentServiceClient is a client for the devloop.v1.AgentService service.
type AgentServiceClient interface {
	// Retrieve the complete devloop configuration for a project to understand
	// available rules, commands, file watch patterns, and project settings.
	//
	// Essential information provided:
	// - Available build/test rules (rules[].name)
	// - Commands executed by each rule (rules[].commands)
	// - File patterns that trigger each rule (rules[].watch patterns)
	// - Project settings like colors, logging, debouncing
	//
	// Usage Examples:
	// - Discover available rules: Parse rules[].name from response
	// - Find test commands: Look for rules with "test" in name or commands
	// - Understand file triggers: Examine rules[].watch.patterns
	//
	// Response Format: JSON string containing the complete .devloop.yaml content
	// with resolved settings and rule definitions.
	// mcp_tool_name:get_config
	GetConfig(context.Context, *connect.Request[v1.GetConfigRequest]) (*connect.Response[v1.GetConfigResponse], error)
	// Get the current execution status and history of a specific rule.
	// Use this to monitor build/test progress and check for failures.
	//
	// Status Information Provided:
	// - Whether the rule is currently running
	// - When the current/last execution started
	// - Result of the last execution (SUCCESS, FAILED, RUNNING, IDLE)
	// - Execution history timestamps
	//
	// Common Use Cases:
	// - Check if a build is still running after triggering
	// - Verify if tests passed or failed
	// - Monitor long-running development servers
	// - Debug why a rule isn't executing
	//
	// Returns: Detailed status including timing and execution results
	// mcp_tool_name:get_rule_status
	GetRule(context.Context, *connect.Request[v1.GetRuleRequest]) (*connect.Response[v1.GetRuleResponse], error)
	// Manually execute a specific rule to run builds, tests, or other commands.
	// This bypasses file watching and immediately starts the rule's command sequence.
	//
	// Trigger Behavior:
	// - Terminates any currently running instance of the rule
	// - Executes all commands in the rule definition sequentially
	// - Updates rule status to RUNNING, then SUCCESS/FAILED based on results
	// - Generates log output that can be retrieved via streaming endpoints
	//
	// Common Use Cases:
	// - Run builds on demand ("trigger the backend build")
	// - Execute test suites ("run the test rule")
	// - Restart development servers ("trigger the dev-server rule")
	// - Force regeneration ("trigger the protobuf rule")
	//
	// Returns: Immediate response indicating if trigger was accepted
	// Use GetRule() to monitor actual execution progress
	// mcp_tool_name:trigger_rule
	TriggerRule(context.Context, *connect.Request[v1.TriggerRuleRequest]) (*connect.Response[v1.TriggerRuleResponse], error)
	// List all file glob patterns being monitored by a project for automatic rule triggering.
	// Use this to understand what files cause rebuilds and which rules will execute.
	//
	// Pattern Information:
	// - All include/exclude patterns from all rules combined
	// - Glob syntax: **/*.go, src/**/*.js, **/test_*.py, etc.
	// - Patterns are resolved relative to the project root
	//
	// Common Use Cases:
	// - Understand what file changes trigger builds
	// - Debug why edits aren't triggering rules
	// - Plan file organization to optimize build triggers
	// - Analyze project structure and dependencies
	//
	// Returns: Array of glob patterns currently being watched
	// mcp_tool_name:list_watched_paths
	ListWatchedPaths(context.Context, *connect.Request[v1.ListWatchedPathsRequest]) (*connect.Response[v1.ListWatchedPathsResponse], error)
	// Stream real-time logs for a specific rule in a project.
	// mcp_tool_name:stream_logs
	StreamLogs(context.Context, *connect.Request[v1.StreamLogsRequest]) (*connect.ServerStreamForClient[v1.StreamLogsResponse], error)
}

// NewAgentServiceClient constructs a client for the devloop.v1.AgentService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewAgentServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) AgentServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	agentServiceMethods := v1.File_devloop_v1_agents_proto.Services().ByName("AgentService").Methods()
	return &agentServiceClient{
		getConfig: connect.NewClient[v1.GetConfigRequest, v1.GetConfigResponse](
			httpClient,
			baseURL+AgentServiceGetConfigProcedure,
			connect.WithSchema(agentServiceMethods.ByName("GetConfig")),
			connect.WithClientOptions(opts...),
		),
		getRule: connect.NewClient[v1.GetRuleRequest, v1.GetRuleResponse](
			httpClient,
			baseURL+AgentServiceGetRuleProcedure,
			connect.WithSchema(agentServiceMethods.ByName("GetRule")),
			connect.WithClientOptions(opts...),
		),
		triggerRule: connect.NewClient[v1.TriggerRuleRequest, v1.TriggerRuleResponse](
			httpClient,
			baseURL+AgentServiceTriggerRuleProcedure,
			connect.WithSchema(agentServiceMethods.ByName("TriggerRule")),
			connect.WithClientOptions(opts...),
		),
		listWatchedPaths: connect.NewClient[v1.ListWatchedPathsRequest, v1.ListWatchedPathsResponse](
			httpClient,
			baseURL+AgentServiceListWatchedPathsProcedure,
			connect.WithSchema(agentServiceMethods.ByName("ListWatchedPaths")),
			connect.WithClientOptions(opts...),
		),
		streamLogs: connect.NewClient[v1.StreamLogsRequest, v1.StreamLogsResponse](
			httpClient,
			baseURL+AgentServiceStreamLogsProcedure,
			connect.WithSchema(agentServiceMethods.ByName("StreamLogs")),
			connect.WithClientOptions(opts...),
		),
	}
}

// agentServiceClient implements AgentServiceClient.
type agentServiceClient struct {
	getConfig        *connect.Client[v1.GetConfigRequest, v1.GetConfigResponse]
	getRule          *connect.Client[v1.GetRuleRequest, v1.GetRuleResponse]
	triggerRule      *connect.Client[v1.TriggerRuleRequest, v1.TriggerRuleResponse]
	listWatchedPaths *connect.Client[v1.ListWatchedPathsRequest, v1.ListWatchedPathsResponse]
	streamLogs       *connect.Client[v1.StreamLogsRequest, v1.StreamLogsResponse]
}

// GetConfig calls devloop.v1.AgentService.GetConfig.
func (c *agentServiceClient) GetConfig(ctx context.Context, req *connect.Request[v1.GetConfigRequest]) (*connect.Response[v1.GetConfigResponse], error) {
	return c.getConfig.CallUnary(ctx, req)
}

// GetRule calls devloop.v1.AgentService.GetRule.
func (c *agentServiceClient) GetRule(ctx context.Context, req *connect.Request[v1.GetRuleRequest]) (*connect.Response[v1.GetRuleResponse], error) {
	return c.getRule.CallUnary(ctx, req)
}

// TriggerRule calls devloop.v1.AgentService.TriggerRule.
func (c *agentServiceClient) TriggerRule(ctx context.Context, req *connect.Request[v1.TriggerRuleRequest]) (*connect.Response[v1.TriggerRuleResponse], error) {
	return c.triggerRule.CallUnary(ctx, req)
}

// ListWatchedPaths calls devloop.v1.AgentService.ListWatchedPaths.
func (c *agentServiceClient) ListWatchedPaths(ctx context.Context, req *connect.Request[v1.ListWatchedPathsRequest]) (*connect.Response[v1.ListWatchedPathsResponse], error) {
	return c.listWatchedPaths.CallUnary(ctx, req)
}

// StreamLogs calls devloop.v1.AgentService.StreamLogs.
func (c *agentServiceClient) StreamLogs(ctx context.Context, req *connect.Request[v1.StreamLogsRequest]) (*connect.ServerStreamForClient[v1.StreamLogsResponse], error) {
	return c.streamLogs.CallServerStream(ctx, req)
}

// AgentServiceHandler is an implementation of the devloop.v1.AgentService service.
type AgentServiceHandler interface {
	// Retrieve the complete devloop configuration for a project to understand
	// available rules, commands, file watch patterns, and project settings.
	//
	// Essential information provided:
	// - Available build/test rules (rules[].name)
	// - Commands executed by each rule (rules[].commands)
	// - File patterns that trigger each rule (rules[].watch patterns)
	// - Project settings like colors, logging, debouncing
	//
	// Usage Examples:
	// - Discover available rules: Parse rules[].name from response
	// - Find test commands: Look for rules with "test" in name or commands
	// - Understand file triggers: Examine rules[].watch.patterns
	//
	// Response Format: JSON string containing the complete .devloop.yaml content
	// with resolved settings and rule definitions.
	// mcp_tool_name:get_config
	GetConfig(context.Context, *connect.Request[v1.GetConfigRequest]) (*connect.Response[v1.GetConfigResponse], error)
	// Get the current execution status and history of a specific rule.
	// Use this to monitor build/test progress and check for failures.
	//
	// Status Information Provided:
	// - Whether the rule is currently running
	// - When the current/last execution started
	// - Result of the last execution (SUCCESS, FAILED, RUNNING, IDLE)
	// - Execution history timestamps
	//
	// Common Use Cases:
	// - Check if a build is still running after triggering
	// - Verify if tests passed or failed
	// - Monitor long-running development servers
	// - Debug why a rule isn't executing
	//
	// Returns: Detailed status including timing and execution results
	// mcp_tool_name:get_rule_status
	GetRule(context.Context, *connect.Request[v1.GetRuleRequest]) (*connect.Response[v1.GetRuleResponse], error)
	// Manually execute a specific rule to run builds, tests, or other commands.
	// This bypasses file watching and immediately starts the rule's command sequence.
	//
	// Trigger Behavior:
	// - Terminates any currently running instance of the rule
	// - Executes all commands in the rule definition sequentially
	// - Updates rule status to RUNNING, then SUCCESS/FAILED based on results
	// - Generates log output that can be retrieved via streaming endpoints
	//
	// Common Use Cases:
	// - Run builds on demand ("trigger the backend build")
	// - Execute test suites ("run the test rule")
	// - Restart development servers ("trigger the dev-server rule")
	// - Force regeneration ("trigger the protobuf rule")
	//
	// Returns: Immediate response indicating if trigger was accepted
	// Use GetRule() to monitor actual execution progress
	// mcp_tool_name:trigger_rule
	TriggerRule(context.Context, *connect.Request[v1.TriggerRuleRequest]) (*connect.Response[v1.TriggerRuleResponse], error)
	// List all file glob patterns being monitored by a project for automatic rule triggering.
	// Use this to understand what files cause rebuilds and which rules will execute.
	//
	// Pattern Information:
	// - All include/exclude patterns from all rules combined
	// - Glob syntax: **/*.go, src/**/*.js, **/test_*.py, etc.
	// - Patterns are resolved relative to the project root
	//
	// Common Use Cases:
	// - Understand what file changes trigger builds
	// - Debug why edits aren't triggering rules
	// - Plan file organization to optimize build triggers
	// - Analyze project structure and dependencies
	//
	// Returns: Array of glob patterns currently being watched
	// mcp_tool_name:list_watched_paths
	ListWatchedPaths(context.Context, *connect.Request[v1.ListWatchedPathsRequest]) (*connect.Response[v1.ListWatchedPathsResponse], error)
	// Stream real-time logs for a specific rule in a project.
	// mcp_tool_name:stream_logs
	StreamLogs(context.Context, *connect.Request[v1.StreamLogsRequest], *connect.ServerStream[v1.StreamLogsResponse]) error
}

// NewAgentServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewAgentServiceHandler(svc AgentServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	agentServiceMethods := v1.File_devloop_v1_agents_proto.Services().ByName("AgentService").Methods()
	agentServiceGetConfigHandler := connect.NewUnaryHandler(
		AgentServiceGetConfigProcedure,
		svc.GetConfig,
		connect.WithSchema(agentServiceMethods.ByName("GetConfig")),
		connect.WithHandlerOptions(opts...),
	)
	agentServiceGetRuleHandler := connect.NewUnaryHandler(
		AgentServiceGetRuleProcedure,
		svc.GetRule,
		connect.WithSchema(agentServiceMethods.ByName("GetRule")),
		connect.WithHandlerOptions(opts...),
	)
	agentServiceTriggerRuleHandler := connect.NewUnaryHandler(
		AgentServiceTriggerRuleProcedure,
		svc.TriggerRule,
		connect.WithSchema(agentServiceMethods.ByName("TriggerRule")),
		connect.WithHandlerOptions(opts...),
	)
	agentServiceListWatchedPathsHandler := connect.NewUnaryHandler(
		AgentServiceListWatchedPathsProcedure,
		svc.ListWatchedPaths,
		connect.WithSchema(agentServiceMethods.ByName("ListWatchedPaths")),
		connect.WithHandlerOptions(opts...),
	)
	agentServiceStreamLogsHandler := connect.NewServerStreamHandler(
		AgentServiceStreamLogsProcedure,
		svc.StreamLogs,
		connect.WithSchema(agentServiceMethods.ByName("StreamLogs")),
		connect.WithHandlerOptions(opts...),
	)
	return "/devloop.v1.AgentService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case AgentServiceGetConfigProcedure:
			agentServiceGetConfigHandler.ServeHTTP(w, r)
		case AgentServiceGetRuleProcedure:
			agentServiceGetRuleHandler.ServeHTTP(w, r)
		case AgentServiceTriggerRuleProcedure:
			agentServiceTriggerRuleHandler.ServeHTTP(w, r)
		case AgentServiceListWatchedPathsProcedure:
			agentServiceListWatchedPathsHandler.ServeHTTP(w, r)
		case AgentServiceStreamLogsProcedure:
			agentServiceStreamLogsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedAgentServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedAgentServiceHandler struct{}

func (UnimplementedAgentServiceHandler) GetConfig(context.Context, *connect.Request[v1.GetConfigRequest]) (*connect.Response[v1.GetConfigResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("devloop.v1.AgentService.GetConfig is not implemented"))
}

func (UnimplementedAgentServiceHandler) GetRule(context.Context, *connect.Request[v1.GetRuleRequest]) (*connect.Response[v1.GetRuleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("devloop.v1.AgentService.GetRule is not implemented"))
}

func (UnimplementedAgentServiceHandler) TriggerRule(context.Context, *connect.Request[v1.TriggerRuleRequest]) (*connect.Response[v1.TriggerRuleResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("devloop.v1.AgentService.TriggerRule is not implemented"))
}

func (UnimplementedAgentServiceHandler) ListWatchedPaths(context.Context, *connect.Request[v1.ListWatchedPathsRequest]) (*connect.Response[v1.ListWatchedPathsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("devloop.v1.AgentService.ListWatchedPaths is not implemented"))
}

func (UnimplementedAgentServiceHandler) StreamLogs(context.Context, *connect.Request[v1.StreamLogsRequest], *connect.ServerStream[v1.StreamLogsResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("devloop.v1.AgentService.StreamLogs is not implemented"))
}
