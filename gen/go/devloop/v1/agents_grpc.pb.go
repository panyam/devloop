// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: devloop/v1/agents.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AgentService_GetConfig_FullMethodName        = "/devloop.v1.AgentService/GetConfig"
	AgentService_GetRule_FullMethodName          = "/devloop.v1.AgentService/GetRule"
	AgentService_TriggerRule_FullMethodName      = "/devloop.v1.AgentService/TriggerRule"
	AgentService_ListWatchedPaths_FullMethodName = "/devloop.v1.AgentService/ListWatchedPaths"
	AgentService_StreamLogs_FullMethodName       = "/devloop.v1.AgentService/StreamLogs"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// AgentService defines the gRPC service for clients to interact with
// a single devloop instance for automated development workflows and monitoring.
//
// Common Workflow Patterns:
// 1. GetConfig -> GetConfig() -> understand available rules
// 2. Build/Test: TriggerRule(rule_name) -> GetRule() -> monitor progress
// 3. Debugging: GetRule() -> ReadFileContent() -> analyze issues
// 4. Monitoring: ListWatchedPaths() -> understand what files trigger rebuilds
type AgentServiceClient interface {
	// Retrieve the complete devloop configuration for a project to understand
	// available rules, commands, file watch patterns, and project settings.
	//
	// Essential information provided:
	// - Available build/test rules (rules[].name)
	// - Commands executed by each rule (rules[].commands)
	// - File patterns that trigger each rule (rules[].watch patterns)
	// - Project settings like colors, logging, debouncing
	//
	// Usage Examples:
	// - Discover available rules: Parse rules[].name from response
	// - Find test commands: Look for rules with "test" in name or commands
	// - Understand file triggers: Examine rules[].watch.patterns
	//
	// Response Format: JSON string containing the complete .devloop.yaml content
	// with resolved settings and rule definitions.
	// mcp_tool_name:get_config
	GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*GetConfigResponse, error)
	// Get the current execution status and history of a specific rule.
	// Use this to monitor build/test progress and check for failures.
	//
	// Status Information Provided:
	// - Whether the rule is currently running
	// - When the current/last execution started
	// - Result of the last execution (SUCCESS, FAILED, RUNNING, IDLE)
	// - Execution history timestamps
	//
	// Common Use Cases:
	// - Check if a build is still running after triggering
	// - Verify if tests passed or failed
	// - Monitor long-running development servers
	// - Debug why a rule isn't executing
	//
	// Returns: Detailed status including timing and execution results
	// mcp_tool_name:get_rule_status
	GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*GetRuleResponse, error)
	// Manually execute a specific rule to run builds, tests, or other commands.
	// This bypasses file watching and immediately starts the rule's command sequence.
	//
	// Trigger Behavior:
	// - Terminates any currently running instance of the rule
	// - Executes all commands in the rule definition sequentially
	// - Updates rule status to RUNNING, then SUCCESS/FAILED based on results
	// - Generates log output that can be retrieved via streaming endpoints
	//
	// Common Use Cases:
	// - Run builds on demand ("trigger the backend build")
	// - Execute test suites ("run the test rule")
	// - Restart development servers ("trigger the dev-server rule")
	// - Force regeneration ("trigger the protobuf rule")
	//
	// Returns: Immediate response indicating if trigger was accepted
	// Use GetRule() to monitor actual execution progress
	// mcp_tool_name:trigger_rule
	TriggerRule(ctx context.Context, in *TriggerRuleRequest, opts ...grpc.CallOption) (*TriggerRuleResponse, error)
	// List all file glob patterns being monitored by a project for automatic rule triggering.
	// Use this to understand what files cause rebuilds and which rules will execute.
	//
	// Pattern Information:
	// - All include/exclude patterns from all rules combined
	// - Glob syntax: **/*.go, src/**/*.js, **/test_*.py, etc.
	// - Patterns are resolved relative to the project root
	//
	// Common Use Cases:
	// - Understand what file changes trigger builds
	// - Debug why edits aren't triggering rules
	// - Plan file organization to optimize build triggers
	// - Analyze project structure and dependencies
	//
	// Returns: Array of glob patterns currently being watched
	// mcp_tool_name:list_watched_paths
	ListWatchedPaths(ctx context.Context, in *ListWatchedPathsRequest, opts ...grpc.CallOption) (*ListWatchedPathsResponse, error)
	// Stream real-time logs for a specific rule in a project.
	// mcp_tool_name:stream_logs
	StreamLogs(ctx context.Context, in *StreamLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamLogsResponse], error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) GetConfig(ctx context.Context, in *GetConfigRequest, opts ...grpc.CallOption) (*GetConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConfigResponse)
	err := c.cc.Invoke(ctx, AgentService_GetConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*GetRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRuleResponse)
	err := c.cc.Invoke(ctx, AgentService_GetRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) TriggerRule(ctx context.Context, in *TriggerRuleRequest, opts ...grpc.CallOption) (*TriggerRuleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TriggerRuleResponse)
	err := c.cc.Invoke(ctx, AgentService_TriggerRule_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) ListWatchedPaths(ctx context.Context, in *ListWatchedPathsRequest, opts ...grpc.CallOption) (*ListWatchedPathsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListWatchedPathsResponse)
	err := c.cc.Invoke(ctx, AgentService_ListWatchedPaths_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) StreamLogs(ctx context.Context, in *StreamLogsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[StreamLogsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &AgentService_ServiceDesc.Streams[0], AgentService_StreamLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamLogsRequest, StreamLogsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_StreamLogsClient = grpc.ServerStreamingClient[StreamLogsResponse]

// AgentServiceServer is the server API for AgentService service.
// All implementations should embed UnimplementedAgentServiceServer
// for forward compatibility.
//
// AgentService defines the gRPC service for clients to interact with
// a single devloop instance for automated development workflows and monitoring.
//
// Common Workflow Patterns:
// 1. GetConfig -> GetConfig() -> understand available rules
// 2. Build/Test: TriggerRule(rule_name) -> GetRule() -> monitor progress
// 3. Debugging: GetRule() -> ReadFileContent() -> analyze issues
// 4. Monitoring: ListWatchedPaths() -> understand what files trigger rebuilds
type AgentServiceServer interface {
	// Retrieve the complete devloop configuration for a project to understand
	// available rules, commands, file watch patterns, and project settings.
	//
	// Essential information provided:
	// - Available build/test rules (rules[].name)
	// - Commands executed by each rule (rules[].commands)
	// - File patterns that trigger each rule (rules[].watch patterns)
	// - Project settings like colors, logging, debouncing
	//
	// Usage Examples:
	// - Discover available rules: Parse rules[].name from response
	// - Find test commands: Look for rules with "test" in name or commands
	// - Understand file triggers: Examine rules[].watch.patterns
	//
	// Response Format: JSON string containing the complete .devloop.yaml content
	// with resolved settings and rule definitions.
	// mcp_tool_name:get_config
	GetConfig(context.Context, *GetConfigRequest) (*GetConfigResponse, error)
	// Get the current execution status and history of a specific rule.
	// Use this to monitor build/test progress and check for failures.
	//
	// Status Information Provided:
	// - Whether the rule is currently running
	// - When the current/last execution started
	// - Result of the last execution (SUCCESS, FAILED, RUNNING, IDLE)
	// - Execution history timestamps
	//
	// Common Use Cases:
	// - Check if a build is still running after triggering
	// - Verify if tests passed or failed
	// - Monitor long-running development servers
	// - Debug why a rule isn't executing
	//
	// Returns: Detailed status including timing and execution results
	// mcp_tool_name:get_rule_status
	GetRule(context.Context, *GetRuleRequest) (*GetRuleResponse, error)
	// Manually execute a specific rule to run builds, tests, or other commands.
	// This bypasses file watching and immediately starts the rule's command sequence.
	//
	// Trigger Behavior:
	// - Terminates any currently running instance of the rule
	// - Executes all commands in the rule definition sequentially
	// - Updates rule status to RUNNING, then SUCCESS/FAILED based on results
	// - Generates log output that can be retrieved via streaming endpoints
	//
	// Common Use Cases:
	// - Run builds on demand ("trigger the backend build")
	// - Execute test suites ("run the test rule")
	// - Restart development servers ("trigger the dev-server rule")
	// - Force regeneration ("trigger the protobuf rule")
	//
	// Returns: Immediate response indicating if trigger was accepted
	// Use GetRule() to monitor actual execution progress
	// mcp_tool_name:trigger_rule
	TriggerRule(context.Context, *TriggerRuleRequest) (*TriggerRuleResponse, error)
	// List all file glob patterns being monitored by a project for automatic rule triggering.
	// Use this to understand what files cause rebuilds and which rules will execute.
	//
	// Pattern Information:
	// - All include/exclude patterns from all rules combined
	// - Glob syntax: **/*.go, src/**/*.js, **/test_*.py, etc.
	// - Patterns are resolved relative to the project root
	//
	// Common Use Cases:
	// - Understand what file changes trigger builds
	// - Debug why edits aren't triggering rules
	// - Plan file organization to optimize build triggers
	// - Analyze project structure and dependencies
	//
	// Returns: Array of glob patterns currently being watched
	// mcp_tool_name:list_watched_paths
	ListWatchedPaths(context.Context, *ListWatchedPathsRequest) (*ListWatchedPathsResponse, error)
	// Stream real-time logs for a specific rule in a project.
	// mcp_tool_name:stream_logs
	StreamLogs(*StreamLogsRequest, grpc.ServerStreamingServer[StreamLogsResponse]) error
}

// UnimplementedAgentServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServiceServer struct{}

func (UnimplementedAgentServiceServer) GetConfig(context.Context, *GetConfigRequest) (*GetConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfig not implemented")
}
func (UnimplementedAgentServiceServer) GetRule(context.Context, *GetRuleRequest) (*GetRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedAgentServiceServer) TriggerRule(context.Context, *TriggerRuleRequest) (*TriggerRuleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerRule not implemented")
}
func (UnimplementedAgentServiceServer) ListWatchedPaths(context.Context, *ListWatchedPathsRequest) (*ListWatchedPathsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWatchedPaths not implemented")
}
func (UnimplementedAgentServiceServer) StreamLogs(*StreamLogsRequest, grpc.ServerStreamingServer[StreamLogsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method StreamLogs not implemented")
}
func (UnimplementedAgentServiceServer) testEmbeddedByValue() {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	// If the following call pancis, it indicates UnimplementedAgentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetConfig(ctx, req.(*GetConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetRule(ctx, req.(*GetRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_TriggerRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TriggerRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).TriggerRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_TriggerRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).TriggerRule(ctx, req.(*TriggerRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_ListWatchedPaths_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWatchedPathsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).ListWatchedPaths(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_ListWatchedPaths_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).ListWatchedPaths(ctx, req.(*ListWatchedPathsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_StreamLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServiceServer).StreamLogs(m, &grpc.GenericServerStream[StreamLogsRequest, StreamLogsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type AgentService_StreamLogsServer = grpc.ServerStreamingServer[StreamLogsResponse]

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "devloop.v1.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfig",
			Handler:    _AgentService_GetConfig_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _AgentService_GetRule_Handler,
		},
		{
			MethodName: "TriggerRule",
			Handler:    _AgentService_TriggerRule_Handler,
		},
		{
			MethodName: "ListWatchedPaths",
			Handler:    _AgentService_ListWatchedPaths_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLogs",
			Handler:       _AgentService_StreamLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "devloop/v1/agents.proto",
}
